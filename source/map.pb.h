// Generated by the protocol buffer compiler.  DO NOT EDIT!

#ifndef PROTOBUF_map_2eproto__INCLUDED
#define PROTOBUF_map_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>

namespace indoor_context {
namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_map_2eproto();
void protobuf_AssignDesc_map_2eproto();
void protobuf_ShutdownFile_map_2eproto();

class Vec2;
class Vec3;
class Vec4;
class Vec5;
class Vec6;
class FloorPlan;
class ImagePng;
class TruthedFrame;
class TruthedMap;

// ===================================================================

class Vec2 : public ::google::protobuf::Message {
 public:
  Vec2();
  virtual ~Vec2();
  
  Vec2(const Vec2& from);
  
  inline Vec2& operator=(const Vec2& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Vec2& default_instance();
  void Swap(Vec2* other);
  
  // implements Message ----------------------------------------------
  
  Vec2* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vec2& from);
  void MergeFrom(const Vec2& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required double x1 = 1;
  inline bool has_x1() const;
  inline void clear_x1();
  static const int kX1FieldNumber = 1;
  inline double x1() const;
  inline void set_x1(double value);
  
  // required double x2 = 2;
  inline bool has_x2() const;
  inline void clear_x2();
  static const int kX2FieldNumber = 2;
  inline double x2() const;
  inline void set_x2(double value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  double x1_;
  double x2_;
  friend void  protobuf_AddDesc_map_2eproto();
  friend void protobuf_AssignDesc_map_2eproto();
  friend void protobuf_ShutdownFile_map_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Vec2* default_instance_;
};
// -------------------------------------------------------------------

class Vec3 : public ::google::protobuf::Message {
 public:
  Vec3();
  virtual ~Vec3();
  
  Vec3(const Vec3& from);
  
  inline Vec3& operator=(const Vec3& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Vec3& default_instance();
  void Swap(Vec3* other);
  
  // implements Message ----------------------------------------------
  
  Vec3* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vec3& from);
  void MergeFrom(const Vec3& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required double x1 = 1;
  inline bool has_x1() const;
  inline void clear_x1();
  static const int kX1FieldNumber = 1;
  inline double x1() const;
  inline void set_x1(double value);
  
  // required double x2 = 2;
  inline bool has_x2() const;
  inline void clear_x2();
  static const int kX2FieldNumber = 2;
  inline double x2() const;
  inline void set_x2(double value);
  
  // required double x3 = 3;
  inline bool has_x3() const;
  inline void clear_x3();
  static const int kX3FieldNumber = 3;
  inline double x3() const;
  inline void set_x3(double value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  double x1_;
  double x2_;
  double x3_;
  friend void  protobuf_AddDesc_map_2eproto();
  friend void protobuf_AssignDesc_map_2eproto();
  friend void protobuf_ShutdownFile_map_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Vec3* default_instance_;
};
// -------------------------------------------------------------------

class Vec4 : public ::google::protobuf::Message {
 public:
  Vec4();
  virtual ~Vec4();
  
  Vec4(const Vec4& from);
  
  inline Vec4& operator=(const Vec4& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Vec4& default_instance();
  void Swap(Vec4* other);
  
  // implements Message ----------------------------------------------
  
  Vec4* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vec4& from);
  void MergeFrom(const Vec4& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required double x1 = 1;
  inline bool has_x1() const;
  inline void clear_x1();
  static const int kX1FieldNumber = 1;
  inline double x1() const;
  inline void set_x1(double value);
  
  // required double x2 = 2;
  inline bool has_x2() const;
  inline void clear_x2();
  static const int kX2FieldNumber = 2;
  inline double x2() const;
  inline void set_x2(double value);
  
  // required double x3 = 3;
  inline bool has_x3() const;
  inline void clear_x3();
  static const int kX3FieldNumber = 3;
  inline double x3() const;
  inline void set_x3(double value);
  
  // required double x4 = 4;
  inline bool has_x4() const;
  inline void clear_x4();
  static const int kX4FieldNumber = 4;
  inline double x4() const;
  inline void set_x4(double value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  double x1_;
  double x2_;
  double x3_;
  double x4_;
  friend void  protobuf_AddDesc_map_2eproto();
  friend void protobuf_AssignDesc_map_2eproto();
  friend void protobuf_ShutdownFile_map_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Vec4* default_instance_;
};
// -------------------------------------------------------------------

class Vec5 : public ::google::protobuf::Message {
 public:
  Vec5();
  virtual ~Vec5();
  
  Vec5(const Vec5& from);
  
  inline Vec5& operator=(const Vec5& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Vec5& default_instance();
  void Swap(Vec5* other);
  
  // implements Message ----------------------------------------------
  
  Vec5* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vec5& from);
  void MergeFrom(const Vec5& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required double x1 = 1;
  inline bool has_x1() const;
  inline void clear_x1();
  static const int kX1FieldNumber = 1;
  inline double x1() const;
  inline void set_x1(double value);
  
  // required double x2 = 2;
  inline bool has_x2() const;
  inline void clear_x2();
  static const int kX2FieldNumber = 2;
  inline double x2() const;
  inline void set_x2(double value);
  
  // required double x3 = 3;
  inline bool has_x3() const;
  inline void clear_x3();
  static const int kX3FieldNumber = 3;
  inline double x3() const;
  inline void set_x3(double value);
  
  // required double x4 = 4;
  inline bool has_x4() const;
  inline void clear_x4();
  static const int kX4FieldNumber = 4;
  inline double x4() const;
  inline void set_x4(double value);
  
  // required double x5 = 5;
  inline bool has_x5() const;
  inline void clear_x5();
  static const int kX5FieldNumber = 5;
  inline double x5() const;
  inline void set_x5(double value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  double x1_;
  double x2_;
  double x3_;
  double x4_;
  double x5_;
  friend void  protobuf_AddDesc_map_2eproto();
  friend void protobuf_AssignDesc_map_2eproto();
  friend void protobuf_ShutdownFile_map_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Vec5* default_instance_;
};
// -------------------------------------------------------------------

class Vec6 : public ::google::protobuf::Message {
 public:
  Vec6();
  virtual ~Vec6();
  
  Vec6(const Vec6& from);
  
  inline Vec6& operator=(const Vec6& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Vec6& default_instance();
  void Swap(Vec6* other);
  
  // implements Message ----------------------------------------------
  
  Vec6* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vec6& from);
  void MergeFrom(const Vec6& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required double x1 = 1;
  inline bool has_x1() const;
  inline void clear_x1();
  static const int kX1FieldNumber = 1;
  inline double x1() const;
  inline void set_x1(double value);
  
  // required double x2 = 2;
  inline bool has_x2() const;
  inline void clear_x2();
  static const int kX2FieldNumber = 2;
  inline double x2() const;
  inline void set_x2(double value);
  
  // required double x3 = 3;
  inline bool has_x3() const;
  inline void clear_x3();
  static const int kX3FieldNumber = 3;
  inline double x3() const;
  inline void set_x3(double value);
  
  // required double x4 = 4;
  inline bool has_x4() const;
  inline void clear_x4();
  static const int kX4FieldNumber = 4;
  inline double x4() const;
  inline void set_x4(double value);
  
  // required double x5 = 5;
  inline bool has_x5() const;
  inline void clear_x5();
  static const int kX5FieldNumber = 5;
  inline double x5() const;
  inline void set_x5(double value);
  
  // required double x6 = 6;
  inline bool has_x6() const;
  inline void clear_x6();
  static const int kX6FieldNumber = 6;
  inline double x6() const;
  inline void set_x6(double value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  double x1_;
  double x2_;
  double x3_;
  double x4_;
  double x5_;
  double x6_;
  friend void  protobuf_AddDesc_map_2eproto();
  friend void protobuf_AssignDesc_map_2eproto();
  friend void protobuf_ShutdownFile_map_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Vec6* default_instance_;
};
// -------------------------------------------------------------------

class FloorPlan : public ::google::protobuf::Message {
 public:
  FloorPlan();
  virtual ~FloorPlan();
  
  FloorPlan(const FloorPlan& from);
  
  inline FloorPlan& operator=(const FloorPlan& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FloorPlan& default_instance();
  void Swap(FloorPlan* other);
  
  // implements Message ----------------------------------------------
  
  FloorPlan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FloorPlan& from);
  void MergeFrom(const FloorPlan& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required double zfloor = 1;
  inline bool has_zfloor() const;
  inline void clear_zfloor();
  static const int kZfloorFieldNumber = 1;
  inline double zfloor() const;
  inline void set_zfloor(double value);
  
  // required double zceil = 2;
  inline bool has_zceil() const;
  inline void clear_zceil();
  static const int kZceilFieldNumber = 2;
  inline double zceil() const;
  inline void set_zceil(double value);
  
  // repeated .indoor_context.proto.Vec2 vertices = 3;
  inline int vertices_size() const;
  inline void clear_vertices();
  static const int kVerticesFieldNumber = 3;
  inline const ::google::protobuf::RepeatedPtrField< ::indoor_context::proto::Vec2 >& vertices() const;
  inline ::google::protobuf::RepeatedPtrField< ::indoor_context::proto::Vec2 >* mutable_vertices();
  inline const ::indoor_context::proto::Vec2& vertices(int index) const;
  inline ::indoor_context::proto::Vec2* mutable_vertices(int index);
  inline ::indoor_context::proto::Vec2* add_vertices();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  double zfloor_;
  double zceil_;
  ::google::protobuf::RepeatedPtrField< ::indoor_context::proto::Vec2 > vertices_;
  friend void  protobuf_AddDesc_map_2eproto();
  friend void protobuf_AssignDesc_map_2eproto();
  friend void protobuf_ShutdownFile_map_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FloorPlan* default_instance_;
};
// -------------------------------------------------------------------

class ImagePng : public ::google::protobuf::Message {
 public:
  ImagePng();
  virtual ~ImagePng();
  
  ImagePng(const ImagePng& from);
  
  inline ImagePng& operator=(const ImagePng& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ImagePng& default_instance();
  void Swap(ImagePng* other);
  
  // implements Message ----------------------------------------------
  
  ImagePng* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImagePng& from);
  void MergeFrom(const ImagePng& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 nx = 1;
  inline bool has_nx() const;
  inline void clear_nx();
  static const int kNxFieldNumber = 1;
  inline ::google::protobuf::int32 nx() const;
  inline void set_nx(::google::protobuf::int32 value);
  
  // required int32 ny = 2;
  inline bool has_ny() const;
  inline void clear_ny();
  static const int kNyFieldNumber = 2;
  inline ::google::protobuf::int32 ny() const;
  inline void set_ny(::google::protobuf::int32 value);
  
  // required string data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const char* value, size_t size);
  inline ::std::string* mutable_data();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 nx_;
  ::google::protobuf::int32 ny_;
  ::std::string* data_;
  static const ::std::string _default_data_;
  friend void  protobuf_AddDesc_map_2eproto();
  friend void protobuf_AssignDesc_map_2eproto();
  friend void protobuf_ShutdownFile_map_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ImagePng* default_instance_;
};
// -------------------------------------------------------------------

class TruthedFrame : public ::google::protobuf::Message {
 public:
  TruthedFrame();
  virtual ~TruthedFrame();
  
  TruthedFrame(const TruthedFrame& from);
  
  inline TruthedFrame& operator=(const TruthedFrame& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TruthedFrame& default_instance();
  void Swap(TruthedFrame* other);
  
  // implements Message ----------------------------------------------
  
  TruthedFrame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TruthedFrame& from);
  void MergeFrom(const TruthedFrame& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional .indoor_context.proto.ImagePng orient_map = 2;
  inline bool has_orient_map() const;
  inline void clear_orient_map();
  static const int kOrientMapFieldNumber = 2;
  inline const ::indoor_context::proto::ImagePng& orient_map() const;
  inline ::indoor_context::proto::ImagePng* mutable_orient_map();
  
  // optional string orient_map_file = 3;
  inline bool has_orient_map_file() const;
  inline void clear_orient_map_file();
  static const int kOrientMapFileFieldNumber = 3;
  inline const ::std::string& orient_map_file() const;
  inline void set_orient_map_file(const ::std::string& value);
  inline void set_orient_map_file(const char* value);
  inline void set_orient_map_file(const char* value, size_t size);
  inline ::std::string* mutable_orient_map_file();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 id_;
  ::indoor_context::proto::ImagePng* orient_map_;
  ::std::string* orient_map_file_;
  static const ::std::string _default_orient_map_file_;
  friend void  protobuf_AddDesc_map_2eproto();
  friend void protobuf_AssignDesc_map_2eproto();
  friend void protobuf_ShutdownFile_map_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static TruthedFrame* default_instance_;
};
// -------------------------------------------------------------------

class TruthedMap : public ::google::protobuf::Message {
 public:
  TruthedMap();
  virtual ~TruthedMap();
  
  TruthedMap(const TruthedMap& from);
  
  inline TruthedMap& operator=(const TruthedMap& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TruthedMap& default_instance();
  void Swap(TruthedMap* other);
  
  // implements Message ----------------------------------------------
  
  TruthedMap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TruthedMap& from);
  void MergeFrom(const TruthedMap& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .indoor_context.proto.Vec3 ln_scene_from_slam = 1;
  inline bool has_ln_scene_from_slam() const;
  inline void clear_ln_scene_from_slam();
  static const int kLnSceneFromSlamFieldNumber = 1;
  inline const ::indoor_context::proto::Vec3& ln_scene_from_slam() const;
  inline ::indoor_context::proto::Vec3* mutable_ln_scene_from_slam();
  
  // optional string spec_file = 2;
  inline bool has_spec_file() const;
  inline void clear_spec_file();
  static const int kSpecFileFieldNumber = 2;
  inline const ::std::string& spec_file() const;
  inline void set_spec_file(const ::std::string& value);
  inline void set_spec_file(const char* value);
  inline void set_spec_file(const char* value, size_t size);
  inline ::std::string* mutable_spec_file();
  
  // repeated .indoor_context.proto.TruthedFrame frame = 3;
  inline int frame_size() const;
  inline void clear_frame();
  static const int kFrameFieldNumber = 3;
  inline const ::google::protobuf::RepeatedPtrField< ::indoor_context::proto::TruthedFrame >& frame() const;
  inline ::google::protobuf::RepeatedPtrField< ::indoor_context::proto::TruthedFrame >* mutable_frame();
  inline const ::indoor_context::proto::TruthedFrame& frame(int index) const;
  inline ::indoor_context::proto::TruthedFrame* mutable_frame(int index);
  inline ::indoor_context::proto::TruthedFrame* add_frame();
  
  // optional .indoor_context.proto.FloorPlan floorplan = 4;
  inline bool has_floorplan() const;
  inline void clear_floorplan();
  static const int kFloorplanFieldNumber = 4;
  inline const ::indoor_context::proto::FloorPlan& floorplan() const;
  inline ::indoor_context::proto::FloorPlan* mutable_floorplan();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::indoor_context::proto::Vec3* ln_scene_from_slam_;
  ::std::string* spec_file_;
  static const ::std::string _default_spec_file_;
  ::google::protobuf::RepeatedPtrField< ::indoor_context::proto::TruthedFrame > frame_;
  ::indoor_context::proto::FloorPlan* floorplan_;
  friend void  protobuf_AddDesc_map_2eproto();
  friend void protobuf_AssignDesc_map_2eproto();
  friend void protobuf_ShutdownFile_map_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static TruthedMap* default_instance_;
};
// ===================================================================


// ===================================================================


// ===================================================================

// Vec2

// required double x1 = 1;
inline bool Vec2::has_x1() const {
  return _has_bit(0);
}
inline void Vec2::clear_x1() {
  x1_ = 0;
  _clear_bit(0);
}
inline double Vec2::x1() const {
  return x1_;
}
inline void Vec2::set_x1(double value) {
  _set_bit(0);
  x1_ = value;
}

// required double x2 = 2;
inline bool Vec2::has_x2() const {
  return _has_bit(1);
}
inline void Vec2::clear_x2() {
  x2_ = 0;
  _clear_bit(1);
}
inline double Vec2::x2() const {
  return x2_;
}
inline void Vec2::set_x2(double value) {
  _set_bit(1);
  x2_ = value;
}

// -------------------------------------------------------------------

// Vec3

// required double x1 = 1;
inline bool Vec3::has_x1() const {
  return _has_bit(0);
}
inline void Vec3::clear_x1() {
  x1_ = 0;
  _clear_bit(0);
}
inline double Vec3::x1() const {
  return x1_;
}
inline void Vec3::set_x1(double value) {
  _set_bit(0);
  x1_ = value;
}

// required double x2 = 2;
inline bool Vec3::has_x2() const {
  return _has_bit(1);
}
inline void Vec3::clear_x2() {
  x2_ = 0;
  _clear_bit(1);
}
inline double Vec3::x2() const {
  return x2_;
}
inline void Vec3::set_x2(double value) {
  _set_bit(1);
  x2_ = value;
}

// required double x3 = 3;
inline bool Vec3::has_x3() const {
  return _has_bit(2);
}
inline void Vec3::clear_x3() {
  x3_ = 0;
  _clear_bit(2);
}
inline double Vec3::x3() const {
  return x3_;
}
inline void Vec3::set_x3(double value) {
  _set_bit(2);
  x3_ = value;
}

// -------------------------------------------------------------------

// Vec4

// required double x1 = 1;
inline bool Vec4::has_x1() const {
  return _has_bit(0);
}
inline void Vec4::clear_x1() {
  x1_ = 0;
  _clear_bit(0);
}
inline double Vec4::x1() const {
  return x1_;
}
inline void Vec4::set_x1(double value) {
  _set_bit(0);
  x1_ = value;
}

// required double x2 = 2;
inline bool Vec4::has_x2() const {
  return _has_bit(1);
}
inline void Vec4::clear_x2() {
  x2_ = 0;
  _clear_bit(1);
}
inline double Vec4::x2() const {
  return x2_;
}
inline void Vec4::set_x2(double value) {
  _set_bit(1);
  x2_ = value;
}

// required double x3 = 3;
inline bool Vec4::has_x3() const {
  return _has_bit(2);
}
inline void Vec4::clear_x3() {
  x3_ = 0;
  _clear_bit(2);
}
inline double Vec4::x3() const {
  return x3_;
}
inline void Vec4::set_x3(double value) {
  _set_bit(2);
  x3_ = value;
}

// required double x4 = 4;
inline bool Vec4::has_x4() const {
  return _has_bit(3);
}
inline void Vec4::clear_x4() {
  x4_ = 0;
  _clear_bit(3);
}
inline double Vec4::x4() const {
  return x4_;
}
inline void Vec4::set_x4(double value) {
  _set_bit(3);
  x4_ = value;
}

// -------------------------------------------------------------------

// Vec5

// required double x1 = 1;
inline bool Vec5::has_x1() const {
  return _has_bit(0);
}
inline void Vec5::clear_x1() {
  x1_ = 0;
  _clear_bit(0);
}
inline double Vec5::x1() const {
  return x1_;
}
inline void Vec5::set_x1(double value) {
  _set_bit(0);
  x1_ = value;
}

// required double x2 = 2;
inline bool Vec5::has_x2() const {
  return _has_bit(1);
}
inline void Vec5::clear_x2() {
  x2_ = 0;
  _clear_bit(1);
}
inline double Vec5::x2() const {
  return x2_;
}
inline void Vec5::set_x2(double value) {
  _set_bit(1);
  x2_ = value;
}

// required double x3 = 3;
inline bool Vec5::has_x3() const {
  return _has_bit(2);
}
inline void Vec5::clear_x3() {
  x3_ = 0;
  _clear_bit(2);
}
inline double Vec5::x3() const {
  return x3_;
}
inline void Vec5::set_x3(double value) {
  _set_bit(2);
  x3_ = value;
}

// required double x4 = 4;
inline bool Vec5::has_x4() const {
  return _has_bit(3);
}
inline void Vec5::clear_x4() {
  x4_ = 0;
  _clear_bit(3);
}
inline double Vec5::x4() const {
  return x4_;
}
inline void Vec5::set_x4(double value) {
  _set_bit(3);
  x4_ = value;
}

// required double x5 = 5;
inline bool Vec5::has_x5() const {
  return _has_bit(4);
}
inline void Vec5::clear_x5() {
  x5_ = 0;
  _clear_bit(4);
}
inline double Vec5::x5() const {
  return x5_;
}
inline void Vec5::set_x5(double value) {
  _set_bit(4);
  x5_ = value;
}

// -------------------------------------------------------------------

// Vec6

// required double x1 = 1;
inline bool Vec6::has_x1() const {
  return _has_bit(0);
}
inline void Vec6::clear_x1() {
  x1_ = 0;
  _clear_bit(0);
}
inline double Vec6::x1() const {
  return x1_;
}
inline void Vec6::set_x1(double value) {
  _set_bit(0);
  x1_ = value;
}

// required double x2 = 2;
inline bool Vec6::has_x2() const {
  return _has_bit(1);
}
inline void Vec6::clear_x2() {
  x2_ = 0;
  _clear_bit(1);
}
inline double Vec6::x2() const {
  return x2_;
}
inline void Vec6::set_x2(double value) {
  _set_bit(1);
  x2_ = value;
}

// required double x3 = 3;
inline bool Vec6::has_x3() const {
  return _has_bit(2);
}
inline void Vec6::clear_x3() {
  x3_ = 0;
  _clear_bit(2);
}
inline double Vec6::x3() const {
  return x3_;
}
inline void Vec6::set_x3(double value) {
  _set_bit(2);
  x3_ = value;
}

// required double x4 = 4;
inline bool Vec6::has_x4() const {
  return _has_bit(3);
}
inline void Vec6::clear_x4() {
  x4_ = 0;
  _clear_bit(3);
}
inline double Vec6::x4() const {
  return x4_;
}
inline void Vec6::set_x4(double value) {
  _set_bit(3);
  x4_ = value;
}

// required double x5 = 5;
inline bool Vec6::has_x5() const {
  return _has_bit(4);
}
inline void Vec6::clear_x5() {
  x5_ = 0;
  _clear_bit(4);
}
inline double Vec6::x5() const {
  return x5_;
}
inline void Vec6::set_x5(double value) {
  _set_bit(4);
  x5_ = value;
}

// required double x6 = 6;
inline bool Vec6::has_x6() const {
  return _has_bit(5);
}
inline void Vec6::clear_x6() {
  x6_ = 0;
  _clear_bit(5);
}
inline double Vec6::x6() const {
  return x6_;
}
inline void Vec6::set_x6(double value) {
  _set_bit(5);
  x6_ = value;
}

// -------------------------------------------------------------------

// FloorPlan

// required double zfloor = 1;
inline bool FloorPlan::has_zfloor() const {
  return _has_bit(0);
}
inline void FloorPlan::clear_zfloor() {
  zfloor_ = 0;
  _clear_bit(0);
}
inline double FloorPlan::zfloor() const {
  return zfloor_;
}
inline void FloorPlan::set_zfloor(double value) {
  _set_bit(0);
  zfloor_ = value;
}

// required double zceil = 2;
inline bool FloorPlan::has_zceil() const {
  return _has_bit(1);
}
inline void FloorPlan::clear_zceil() {
  zceil_ = 0;
  _clear_bit(1);
}
inline double FloorPlan::zceil() const {
  return zceil_;
}
inline void FloorPlan::set_zceil(double value) {
  _set_bit(1);
  zceil_ = value;
}

// repeated .indoor_context.proto.Vec2 vertices = 3;
inline int FloorPlan::vertices_size() const {
  return vertices_.size();
}
inline void FloorPlan::clear_vertices() {
  vertices_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::indoor_context::proto::Vec2 >&
FloorPlan::vertices() const {
  return vertices_;
}
inline ::google::protobuf::RepeatedPtrField< ::indoor_context::proto::Vec2 >*
FloorPlan::mutable_vertices() {
  return &vertices_;
}
inline const ::indoor_context::proto::Vec2& FloorPlan::vertices(int index) const {
  return vertices_.Get(index);
}
inline ::indoor_context::proto::Vec2* FloorPlan::mutable_vertices(int index) {
  return vertices_.Mutable(index);
}
inline ::indoor_context::proto::Vec2* FloorPlan::add_vertices() {
  return vertices_.Add();
}

// -------------------------------------------------------------------

// ImagePng

// required int32 nx = 1;
inline bool ImagePng::has_nx() const {
  return _has_bit(0);
}
inline void ImagePng::clear_nx() {
  nx_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 ImagePng::nx() const {
  return nx_;
}
inline void ImagePng::set_nx(::google::protobuf::int32 value) {
  _set_bit(0);
  nx_ = value;
}

// required int32 ny = 2;
inline bool ImagePng::has_ny() const {
  return _has_bit(1);
}
inline void ImagePng::clear_ny() {
  ny_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 ImagePng::ny() const {
  return ny_;
}
inline void ImagePng::set_ny(::google::protobuf::int32 value) {
  _set_bit(1);
  ny_ = value;
}

// required string data = 3;
inline bool ImagePng::has_data() const {
  return _has_bit(2);
}
inline void ImagePng::clear_data() {
  if (data_ != &_default_data_) {
    data_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& ImagePng::data() const {
  return *data_;
}
inline void ImagePng::set_data(const ::std::string& value) {
  _set_bit(2);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ImagePng::set_data(const char* value) {
  _set_bit(2);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ImagePng::set_data(const char* value, size_t size) {
  _set_bit(2);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ImagePng::mutable_data() {
  _set_bit(2);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  return data_;
}

// -------------------------------------------------------------------

// TruthedFrame

// required int32 id = 1;
inline bool TruthedFrame::has_id() const {
  return _has_bit(0);
}
inline void TruthedFrame::clear_id() {
  id_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 TruthedFrame::id() const {
  return id_;
}
inline void TruthedFrame::set_id(::google::protobuf::int32 value) {
  _set_bit(0);
  id_ = value;
}

// optional .indoor_context.proto.ImagePng orient_map = 2;
inline bool TruthedFrame::has_orient_map() const {
  return _has_bit(1);
}
inline void TruthedFrame::clear_orient_map() {
  if (orient_map_ != NULL) orient_map_->::indoor_context::proto::ImagePng::Clear();
  _clear_bit(1);
}
inline const ::indoor_context::proto::ImagePng& TruthedFrame::orient_map() const {
  return orient_map_ != NULL ? *orient_map_ : *default_instance_->orient_map_;
}
inline ::indoor_context::proto::ImagePng* TruthedFrame::mutable_orient_map() {
  _set_bit(1);
  if (orient_map_ == NULL) orient_map_ = new ::indoor_context::proto::ImagePng;
  return orient_map_;
}

// optional string orient_map_file = 3;
inline bool TruthedFrame::has_orient_map_file() const {
  return _has_bit(2);
}
inline void TruthedFrame::clear_orient_map_file() {
  if (orient_map_file_ != &_default_orient_map_file_) {
    orient_map_file_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& TruthedFrame::orient_map_file() const {
  return *orient_map_file_;
}
inline void TruthedFrame::set_orient_map_file(const ::std::string& value) {
  _set_bit(2);
  if (orient_map_file_ == &_default_orient_map_file_) {
    orient_map_file_ = new ::std::string;
  }
  orient_map_file_->assign(value);
}
inline void TruthedFrame::set_orient_map_file(const char* value) {
  _set_bit(2);
  if (orient_map_file_ == &_default_orient_map_file_) {
    orient_map_file_ = new ::std::string;
  }
  orient_map_file_->assign(value);
}
inline void TruthedFrame::set_orient_map_file(const char* value, size_t size) {
  _set_bit(2);
  if (orient_map_file_ == &_default_orient_map_file_) {
    orient_map_file_ = new ::std::string;
  }
  orient_map_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TruthedFrame::mutable_orient_map_file() {
  _set_bit(2);
  if (orient_map_file_ == &_default_orient_map_file_) {
    orient_map_file_ = new ::std::string;
  }
  return orient_map_file_;
}

// -------------------------------------------------------------------

// TruthedMap

// optional .indoor_context.proto.Vec3 ln_scene_from_slam = 1;
inline bool TruthedMap::has_ln_scene_from_slam() const {
  return _has_bit(0);
}
inline void TruthedMap::clear_ln_scene_from_slam() {
  if (ln_scene_from_slam_ != NULL) ln_scene_from_slam_->::indoor_context::proto::Vec3::Clear();
  _clear_bit(0);
}
inline const ::indoor_context::proto::Vec3& TruthedMap::ln_scene_from_slam() const {
  return ln_scene_from_slam_ != NULL ? *ln_scene_from_slam_ : *default_instance_->ln_scene_from_slam_;
}
inline ::indoor_context::proto::Vec3* TruthedMap::mutable_ln_scene_from_slam() {
  _set_bit(0);
  if (ln_scene_from_slam_ == NULL) ln_scene_from_slam_ = new ::indoor_context::proto::Vec3;
  return ln_scene_from_slam_;
}

// optional string spec_file = 2;
inline bool TruthedMap::has_spec_file() const {
  return _has_bit(1);
}
inline void TruthedMap::clear_spec_file() {
  if (spec_file_ != &_default_spec_file_) {
    spec_file_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& TruthedMap::spec_file() const {
  return *spec_file_;
}
inline void TruthedMap::set_spec_file(const ::std::string& value) {
  _set_bit(1);
  if (spec_file_ == &_default_spec_file_) {
    spec_file_ = new ::std::string;
  }
  spec_file_->assign(value);
}
inline void TruthedMap::set_spec_file(const char* value) {
  _set_bit(1);
  if (spec_file_ == &_default_spec_file_) {
    spec_file_ = new ::std::string;
  }
  spec_file_->assign(value);
}
inline void TruthedMap::set_spec_file(const char* value, size_t size) {
  _set_bit(1);
  if (spec_file_ == &_default_spec_file_) {
    spec_file_ = new ::std::string;
  }
  spec_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TruthedMap::mutable_spec_file() {
  _set_bit(1);
  if (spec_file_ == &_default_spec_file_) {
    spec_file_ = new ::std::string;
  }
  return spec_file_;
}

// repeated .indoor_context.proto.TruthedFrame frame = 3;
inline int TruthedMap::frame_size() const {
  return frame_.size();
}
inline void TruthedMap::clear_frame() {
  frame_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::indoor_context::proto::TruthedFrame >&
TruthedMap::frame() const {
  return frame_;
}
inline ::google::protobuf::RepeatedPtrField< ::indoor_context::proto::TruthedFrame >*
TruthedMap::mutable_frame() {
  return &frame_;
}
inline const ::indoor_context::proto::TruthedFrame& TruthedMap::frame(int index) const {
  return frame_.Get(index);
}
inline ::indoor_context::proto::TruthedFrame* TruthedMap::mutable_frame(int index) {
  return frame_.Mutable(index);
}
inline ::indoor_context::proto::TruthedFrame* TruthedMap::add_frame() {
  return frame_.Add();
}

// optional .indoor_context.proto.FloorPlan floorplan = 4;
inline bool TruthedMap::has_floorplan() const {
  return _has_bit(3);
}
inline void TruthedMap::clear_floorplan() {
  if (floorplan_ != NULL) floorplan_->::indoor_context::proto::FloorPlan::Clear();
  _clear_bit(3);
}
inline const ::indoor_context::proto::FloorPlan& TruthedMap::floorplan() const {
  return floorplan_ != NULL ? *floorplan_ : *default_instance_->floorplan_;
}
inline ::indoor_context::proto::FloorPlan* TruthedMap::mutable_floorplan() {
  _set_bit(3);
  if (floorplan_ == NULL) floorplan_ = new ::indoor_context::proto::FloorPlan;
  return floorplan_;
}


}  // namespace proto
}  // namespace indoor_context

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

#endif  // PROTOBUF_map_2eproto__INCLUDED
